/**
 * \file main.h
 * \brief Хедер файл для main.cpp
 *
 *  Этот файл содержит определение структур и классов для работы с односвязаным списком и стеком,
 *  а также объявляет глобавльные переменные и функции для сетевого взаимодействия.
 *
 */
#ifndef MAIN_H
#define MAIN_H

#pragma comment(lib, "Ws2_32.lib")

#include <winsock2.h>
#include <iostream>
#include <ws2tcpip.h>
#include <string>

/**
 * \brief Узел односвязного списка, содержащий сокет.
 *
 *  Этот структурный тип представляет собой элемент односвязного списка, который хранит сокет и указатель на следующий элемент списка.
 */
struct Node {
  SOCKET data;     ///< Сокет клиента.
  Node *next;      ///< Указатель на следующий узел.
  /**
   * \brief Конструктор узла односвязного списка.
   * \param data Сокет клиента.
   *
   *  Создает узел с уникальным сокетом и инициализирует указатель next как nullptr.
   */
  Node(SOCKET data);
};

/**
 * \brief Класс для работы с односвязным списком.
 *
 *  Этот класс представляет методы для управления односвязным списком, который используется для хранения сокетов подключенных клинетов.
 */
class LinkedList {
public:
  /**
   * \brief Конструктор односвязного списка.
   *
   *  Создает пустой односязный список, инициализируя указатель head как nullptr.
   */
  LinkedList();

  /**
   * \brief Добавление узла в конец односвязного списка.
   * \param data Сокет клиента.
   *
   *  Создает новый узел с указанным сокетом и добавляет его в конец списка.
   */
  void append(SOCKET data);

  /**
   * \brief Отображение содержимого односвязного списка.
   *
   *  Выводит на экран данные всех узлов списка.
   */
  void display();

  /**
   * \brief Получение головы односвязного списка.
   * \return Указатель на голову списка.
   *
   *  Возвращает указатель на первый узел списка.
   */
  Node *getHead();

  /**
   * \brief Удаление узла из односвязного списка по значению сокета.
   * \param data Сокет клиента.
   *
   *  Удаляет первый узел с указанным сокетом из списка.
   */
  void remove(SOCKET data);

  /**
   * \brief Деструктор односвязного списка. Удаляет все узлы.
   *
   *  Удаляет все узлы списка, освобождая занятую память.
   */
  ~LinkedList();

private:
  Node *head;      ///< Указатель на голову списка.
};

/**
 * \brief Узел стека, содержащий строку данных.
 *
 *  Этот структурный тип представляет собой элемент стека, который хранит строку данных и указатель на следующий элемент стека.
 */
struct StackNode {
  std::string data;    ///< Строка данных.
  StackNode *next;     ///< Указатель на следующий узел.

  /**
   * \brief Конструктор узла стека.
   * \param data Строка данных.
   *
   *  Создает узел с указанной строкой данных и инициализирует указатель next как nullptr.
   */
  StackNode(std::string data);
};

/**
 * \brief Класс для работы со стеком.
 *
 *  Этот класс представляет методы для управления стеком строковых данных.
 */
class Stack {
public:
  /**
   * \brief Конструктор стека.
   *
   *  Создает пустой стек, инициализируя указатель top как nullptr.
   */
  Stack();

  /**
   * \brief Добавление элемента на вершину стека.
   * \param data Строка данных.
   *
   *  Создает новый узел с указанной строкой данных и добавляет его на вершину стека.
   */
  void push(std::string data);

  /**
   * \brief Удаление и получение элемента с вершины стека.
   * \return Строка данных.
   *
   *  Удаляет верхний узел стека и возвращает хранимую в нем строку данных.
   */
  std::string pop();

  /**
   * \brief Получение элемента с вершины стека без его удаления.
   * \return Строка данных.
   *
   *  Возвращает строку данных верхнего узла стека без его удаления.
   */
  std::string peek();

  /**
   * \brief Проверка, пуст ли стек.
   * \return true, если стек пуст, иначе false.
   */
  bool isEmpty();

  /**
   * \brief Деструктор стека.
   *
   *  Удаляет все узлы стека, освобождая занятую память.
   */
  ~Stack();

private:
  StackNode *top;      ///< Указатель на вершину стека.
};

/**
 * \brief Функция для отправки сообщения клиенту.
 * \param ID Идентификатор клиента.
 *
 *  Отправляет сообщение клиенту с указанным идентификатором через соответствующий сокет.
 */
void SendMessageToClient(int ID);

/**
 * \brief Глобальная переменная, представляющая сокет для прослушивания.
 *
 *  Этот сокет используется сервером для прослушивания входящих подключений.
 */
extern SOCKET Listen;

/**
 * \brief Глобальная переменная, представляющая список подключенных клиентов.
 *
 *  Односвязный список для хранения сокетов всех подключенных клиентов.
 */
extern LinkedList connectionsList;

/**
 * \brief Глобальная переменная, представляющая количество клиентов.
 *
 *  Хранит текущее количество подключенных клиентов.
 */
extern int ClientCount;

#endif // MAIN_H
